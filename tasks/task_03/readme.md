#  Лабораторная работа №3

## Тема

Последовательные контейнеры библиотеки STL.

## Цель задания

1. Создание консольного приложения, состоящего из нескольких файлов в системе  программирования Visual Studio.
2. Использование последовательных контейнеров библиотеки STL в ОО  программе.

## Теоретические сведения

### Основные концепции STL

**STL – Standard Template Library**, стандартная библиотека шаблонов  состоит из двух основных частей: набора контейнерных классов и набора обобщенных  алгоритмов.

`Контейнеры` — это объекты, содержащие другие однотипные объекты.  Контейнерные классы являются шаблонными, поэтому хранимые в них объекты могут быть  как встроенных, так и пользовательских типов.Эти объекты должны допускать копирование и  *присваивание*. Встроенные типы этим требованиям удовлетворяют; то же самое относится к  классам, если конструктор копирования или операция присваивания не объявлены в них  закрытыми или защищенными. Контейнеры *STL* реализуют основные структуры данных,  используемые при написании программ.

`Обобщенные алгоритмы` реализуют большое количество процедур, применимых к  контейнерам: поиск, сортировку, слияние и т. п. Однако они не являются методами  контейнерных классов. Алгоритмы представлены в STL в форме глобальных шаблонных  функций. Благодаря этому достигается универсальность: эти функции можно применять не  только к объектам различных контейнерных классов, но также и к массивам. Независимость  от типов контейнеров достигается за счет косвенной связи функции с контейнером: в  функцию передается не сам контейнер, а пара адресов *first, last*, задающая диапазон обрабатываемых элементов.

`Итераторы` – это обобщение концепции указателей: они ссылаются на элементы  контейнера. Их можно инкрементировать *(++)*, как обычные указатели, для  последовательного продвижения по контейнеру, а также разыменовывать для получения или  изменения значения элемента (*).

### Контейнеры

Контейнеры **STL** можно разделить на два типа: последовательные и ассоциативные.

Последовательные контейнеры обеспечивают хранение конечного количества  однотипных объектов в виде непрерывной последовательности. К базовым последовательным контейнерам относятся векторы (**vector**), списки (**list**) и двусторонние  очереди (**deque**). Есть еще специализированные контейнеры (или адаптеры контейнеров),  реализованные на основе базовых — стеки (**stack**), очереди (**queue**) и очереди с  приоритетами (**priority_queue**).

Для использования контейнера в программе необходимо включить в нее соот- ветствующий заголовочный файл. Тип объектов, сохраняемых в контейнере, задается с  помощью аргумента шаблона, например:

```C++
#include <vector> 
#include <list> 
#include “person.h” 
….. 
vector<int> v; 
list<person> l; 
```

Ассоциативные контейнеры обеспечивают быстрый доступ к данным по ключу. Эти контейнеры построены на основе сбалансированных деревьев. Существует пять типов  ассоциативных контейнеров: словари (**mар**), словари с дубликатами (**multimap**), множества  (**set**), множества с дубликатами (**multiset**) и битовые множества (**bitset**).

### Итераторы

Рассмотрим, как можно реализовать шаблон функции для поиска элементов в  массиве, который хранит объекты типа **Data**:

```C++
template <class Data> 
Data* Find(Data*mas, int n, const Data& key) 
{ 
for(int i=0;i<n;i++) 
if (*(mas + i) == key) 
return mas + i; 
return 0; 
}
```

Функция возвращает адрес найденного элемента или 0, если элемент с заданным  значением не найден. 
Эту функцию можно использовать для поиска элементов в массиве любого типа,  но использовать ее для списка нельзя, поэтому авторы STL ввели понятие итератора.

Итератор более общее понятие, чем указатель. Тип iterator определен для всех  контейнерных классов STL, однако, реализация его в разных классах разная. К основным операциям, выполняемым с любыми итераторами, относятся: ∙ Разыменование итератора: если р — итератор, то *р — значение объекта, на  который он ссылается.

+ Присваивание одного итератора другому.
+ Сравнение итераторов на равенство и неравенство `(== и !=)`.
+ Перемещение его по всем элементам контейнера с помощью префиксного (++р) или постфиксного (р++) инкремента.
  
Так как реализация итератора специфична для каждого класса, то при объявле- нии объектов типа итератор всегда указывается область видимости в форме  имя_шаблона : : , например:

```C++
vector<int>::iterator iterl;  
List<person>::iterator iter2;
```

Организация циклов просмотра элементов контейнеров тоже имеет некоторую  специфику. Так, если **i** — некоторый итератор, то вместо привычной формы `for (i =0; i < n; ++i)` используется следующая:

`for (i = first; i != last; ++i)`, где **first** - значение итератора, указывающее на первый элемент в контейнере,  a **last** — значение итератора, указывающее на воображаемый элемент, который  следует *за* последним элементом контейнера.

first last
Операция сравнения < заменена на операцию ! =, т. к. операции < и > для  итераторов в общем случае не поддерживаются. 
Для всех контейнерных классов определены унифицированные методы  begin() и end(), возвращающие адреса first и last соответственно. В STL существуют следующие типы итераторов:

+ входные,
+ выходные,
+ прямые,
+ двунаправленные итераторы,
+ итераторы произвольного доступа.
